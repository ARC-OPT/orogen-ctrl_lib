name "ctrl_lib"

using_library "ctrl_lib"
import_types_from "ctrl_libTypes.hpp"
import_types_from "ctrl_lib/ActivationFunction.hpp"
import_types_from "base"
using_library "kdl_conversions"

#
# Base class for all controllers. State machine in RUNNING state:
#  1. Update Properties
#  2. Read Feedback term.
#  3. If a feedback term is available, read setpoint. Once there is a setpoint, control output
#     will be written at all times.
#  3. Compute and write control output, depending on the implementation of the controller (derived task)
#  4. Compute activation. The activation indicates how much influence a control output has, compared to the other control outputs. Activation
#     values will be within 0..1. The activation ports can e.g. be connected to WBC in order to deactivate constraint variables and make unneeded
#     dof available for other tasks. A typical example is Joint limits avoidance. Usually one wants to activate the avoidance behavior only when
#     being close to the joint limits and not disturb other tasks when moving freely. Different activation functions can be chosen (e.g. linear, quadratic, ...)
#     in order to achieve smooth transitions.
#
task_context "ControllerTask" do
   abstract
   needs_configuration

   runtime_states "NO_SETPOINT", # Never got a setpoint, no control output will be written
                  "NO_FEEDBACK"  # Never got feedback, no control output will be written

   # Unique name for each variable, e.g. joint names in case of a joint space controller.
   property("field_names", "std/vector<std/string>")

   # Type of activation function used. See ctrl_lib/ActivationFunction.hpp for details.
   property("activation_function", "ctrl_lib/ActivationFunction")

   # Current activation values
   output_port("activation", "base/VectorXd")

   # Current time between two consecutive calls of updateHook()
   output_port("actual_cycle_time", "double")

   # The controllers should be called periodically to achieve best performance.
   periodic 0.01
end

#
# Base class for all proportional controllers.
#
task_context "ProportionalControllerTask" do subclasses "ControllerTask"
   abstract
   needs_configuration

   # Proportional gain. Size has to be the same as size of field_names.
   property("prop_gain", "base/VectorXd").dynamic

   # Feed Forward gain. Size has to be the same as size of field_names.
   property("ff_gain", "base/VectorXd").dynamic

   # Maximum control output (saturation). If one output value exceeds maximum, all
   # other values will be scaled accordingly. Size has to be the same as size of field_names.
   property("max_control_output", "base/VectorXd").dynamic

   # Minimum control error (dead zone). If one control error value falls below this minimum, it will be set to zero.
   property("dead_zone", "base/VectorXd").dynamic

   # Debug Ports

   output_port("current_prop_gain", "base/VectorXd")
   output_port("current_ff_gain", "base/VectorXd")
   output_port("current_max_control_output", "base/VectorXd")
   output_port("current_dead_zone", "base/VectorXd")
   output_port("control_error", "base/VectorXd")

   # Reset setpoint to actual value. Control output will be approx. zero after that action
   operation("reset")

   # Clear setpoint. No control output will be written after that
   operation("clearSetpoint")

   # The controllers should be called periodically to achieve best performance.
   periodic 0.01
end

#
# Implementation of a proportional position controller in joint space.
#
task_context "JointPositionController" do subclasses "ProportionalControllerTask"
   needs_configuration

   # Setpoint of the controller. Joints will be mapped by name internally. Size has to be >= size of field_names. All field names have to be present.
   input_port("setpoint", "base/commands/Joints")
   # Feedback term of the controller. Joints will be mapped by name internally. Size has to be >= size of field_names. All field names have to be present.
   input_port("feedback", "base/samples/Joints")

   # Debug Ports

   output_port("current_setpoint", "base/commands/Joints")
   output_port("current_feedback", "base/samples/Joints")

   # Control output as velocity. Size will be same as size of field_names.
   output_port("control_output", "base/commands/Joints")

   periodic 0.01
end

#
# Implementation of proportional position controller in Cartesian space. Size of field_names has to be 6. The orientation error will be computed
# using zyx rotation. So the control output will be <velocity(xyz), angular_velocity(zyx)>
# 
task_context "CartesianPositionController" do subclasses "ProportionalControllerTask"
   needs_configuration

   # Setpoint of the controller.
   input_port("setpoint", "base/samples/RigidBodyState")
   # Feedback term of the controller.
   input_port("feedback", "base/samples/RigidBodyState")

   # Debug Ports

   output_port("current_setpoint", "base/samples/RigidBodyState")
   output_port("current_feedback", "base/samples/RigidBodyState")

   # Control output as Cartesian velocity/angular velocity.
   output_port("control_output", "base/samples/RigidBodyState")

   periodic 0.01
end

#
# Implementation of a proportional force/torque controller in Cartesian space
#
task_context "CartesianForceController" do subclasses "ProportionalControllerTask"
   needs_configuration

   # Setpoint of the controller
   input_port("setpoint", "base/samples/Wrench")
   # Feedback term of the controller.
   input_port("feedback", "base/samples/Wrench")

   # Debug Ports

   output_port("current_setpoint", "base/samples/Wrench")
   output_port("current_feedback", "base/samples/Wrench")

   # Control output as Cartesian velocity/angular velocity.
   output_port("control_output", "base/samples/RigidBodyState")

   periodic 0.01
end

#
# Base class for all potential field controllers
#
task_context "PotentialFieldsControllerTask" do subclasses "ControllerTask"
   abstract
   needs_configuration

   # Proportional gain. Size has to be the same as size of field_names.
   property("prop_gain", "base/VectorXd").dynamic

   # Maximum control output (saturation). If one output value exceeds maximum, all
   # other values will be scaled accordingly. Size has to be the same as size of field_names.
   property("max_control_output", "base/VectorXd").dynamic

   # Debug ports:

   output_port("field_infos", "std/vector<ctrl_lib/PotentialFieldInfo>")
   output_port("current_prop_gain", "base/VectorXd")
   output_port("current_max_control_output", "base/VectorXd")

   periodic 0.01
end


#
# Implementation of RadialPotentialFields in joint space. Each joint will have one 1-dimensional potential field.
# See ctrl_lib/RadialPotentialField.hpp and ctrl_lib/JointPotentialFieldsController.hpp for details
#
task_context "JointLimitAvoidance" do subclasses "PotentialFieldsControllerTask"
   needs_configuration

   # Default influence distance. Has to be > 0!
   property("influence_distance", "base/VectorXd").dynamic

   # centers of the potential fields. Size has to be either empty or same as size of field_names
   property("joint_limits", "base/JointLimits").dynamic

   # Controller feedback: Actual joint position. Size has to be same as size of field_names. Joints will mapped internally by names.
   # All joints from field_names have to be available here!
   input_port("feedback", "base/samples/Joints")

   # Control output as joint velocity. Size will be same as size of field_names.
   output_port("control_output", "base/commands/Joints")

   # Debug ports

   output_port("current_feedback", "base/samples/Joints")
   output_port("current_influence_distance", "base/VectorXd")
   output_port("current_joint_limits", "base/JointLimits")

   periodic 0.01
end

#
# Implementation of RadialPotentialFields in Cartesian space. Dimension of all fields has to be 3! See ctrl_lib/RadialPotentialField.hpp and
# ctrl_lib/PotentialFieldsController.hpp for details
#
task_context "CartesianRadialPotentialFields" do subclasses "PotentialFieldsControllerTask"
   needs_configuration

   # Influence distance per potential field. All entries have to be > 0! If size of this vector is > 0
   # the derived component will try to map the influence distances by potential field name. If a
   # field name is not given here, the default influence distance will be used
   property("influence_distance_per_field", "std::vector<ctrl_lib/InfluenceDistancePerField>")

   # Default influence distance. Has to be > 0!
   property("influence_distance", "double")

   # Set new centers of the potential fields here. Number of fields can be anything > 0.
   input_port("pot_field_centers",  "std/vector<base/samples/RigidBodyState>")

   # Controller feedback: Actual position of the control frame on the robot. Orientation is not used in this controller
   input_port("feedback", "base/samples/RigidBodyState")

   # Control output as cartesian velocity.
   output_port("control_output",   "base/samples/RigidBodyState")

   # Debug ports:

   output_port("current_feedback", "base/samples/RigidBodyState")

   periodic 0.01
end

typekit do
   export_types "ctrl_lib/ActivationFunction"
end
