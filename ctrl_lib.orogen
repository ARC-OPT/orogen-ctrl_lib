name "ctrl_lib"

import_types_from "base"
using_library "ctrl_lib"
using_library "kdl_conversions"

# Repulsive Potential Field method in joint space. One 1-dim. potential field per joint:
#
# Out: acc = vel = -grad(U) = kp * (1/d - 1/d_0) * (q - q_0)/d^2,  d<= d_0
#                           = 0                                 ,  else
#
#     d = |q-q_0|
#   d_0 = Maximum Influence distance
#   q_0 = Potential field center
#    kp = Proportional gain
#
task_context "JointRepPotField" do
    needs_configuration

    property("joint_names", "std/vector<std/string>").
         doc("Joint Names used for this task")
 
    property("q_zero", "base/VectorXd").
          doc("Potential field center per joint. Has to have same size as joint_names.")

    property("d_zero", "base/VectorXd").
          doc("Maximum influence distance per joint. Has to have same size as joint_names.")

    property("transition_range", "double", 0.5).
          doc("Transition rnage in percentage of the maximum influence distance. Has to be within 0..1.
               Activation function is a piecewise linear function, that increases from 0 to 1.
               The higher this value, the smaller the incline of the activation function.
               For transition_range = 0, the activation will be a step function.")

    property("max_ctrl_out", "base/VectorXd").
          doc("Maximum controller output. Has to have same size as joint_names or empty, in which case infinite control output will be allowed.")

    property("kp", "base/VectorXd").
          doc("Proportional gain. Has to have same size as joint_names.")    
    
    input_port("feedback", "base/samples/Joints").
          doc("Current Joint status. Has to contain at least all names defined by joint_names.")

    output_port("ctrl_out", "base/commands/Joints").
          doc("Controller output (speed).  Will have same size as joint_names.")

    output_port("activation", "base/VectorXd").
          doc("Activation function. Will be between 0 and 1 for each joint.")

    # Debug Ports
    output_port("control_error", "base/samples/Joints")
    
    periodic 0.1
end


# Repulsive Potential Field method in Cartesian space. 3-dim. radial potential field:
#
# Out: acc = vel = -grad(U) = kp * (1/d - 1/d_0) * (x - x_0)/d^2,  d<= d_0
#                           = 0                                 ,  else
#     d = ||x-x_0||
#   d_0 = Maximum Influence distance
#   x_0 = Potential field center
#    kp = Proportional gain
#
task_context "CartRepPotField" do
    needs_configuration

    property("d_zero", "double").
         doc("Maximum radial influence distance")

    property("kp", "base/Vector3d").
         doc("Proportional Gain.")

    property("max_ctrl_out", "base/Vector3d").
         doc("Maximum Controller output.")
 
    property("controlled_frame_frame", "std/string").
         doc("This is the 'end effector' frame of the controlled motion")

    property("controlled_in_frame", "std/string").
         doc("This is the base frame of the controller motion, e.g. the robot base frame")

    property("rep_field_center_frame", "std/string").
         doc("This is the rep_field_center frame of the controller motion")

    output_port("ctrl_out", "base/samples/RigidBodyState").
         doc("Gradient of potential field")
    
    transformer do
      transform 'controlled_in', 'rep_field_center'
      transform 'controlled_in', 'controlled_frame'
      max_latency 0.1
    end

    # Debug Ports
    output_port("control_error", "base/samples/RigidBodyState")

    periodic 0.1
end


# Joint P-controller with velocity feedfoward term:
#   ctrl_out = v_r + kp*(x_r-x), |ctrl_out| <= max_ctrl_out
#
task_context "JointPosCtrlVelFF" do
    needs_configuration
   
    property("joint_names", "std/vector<std/string>").
         doc("Joint Names used for this task")

    property("max_ctrl_out", "base/VectorXd").
         doc("Max controller output. Size has to be either the same as joint_names or left 
              empty, in which case infinite ctrl output will be allowed")

    property("kp", "base/VectorXd").
         doc("Proportional controller parameters. Size has to be same as joint names")

    input_port("setpoint", "base/commands/Joints").
         doc("Reference value for controller. Has to contain at least all names defined by joint_names.")

    input_port("feedback", "base/samples/Joints").
         doc("Current joint state. Has to contain at least all names defined by joint_names.")

    input_port("kp_values", "base/VectorXd").
         doc("Optional port for online setting new gains.")
    
    output_port("ctrl_out", "base/commands/Joints").
         doc("Controller output (speed). Will have same size as joint_names.")

    # For debugging
    output_port("control_error", "base/samples/Joints")

    periodic 0.1
end


# Cartesian P-controller with velocity feedforward term:
#   ctrl_out = v_r + kp*(x_r-x), |ctrl_out| <= max_ctrl_out
#
task_context "CartPosCtrlVelFF" do
    needs_configuration

    property("kp", "base/Vector6d").
       doc("Proportional controller parameters.")

    property("max_ctrl_out", "base/Vector6d").
       doc("Maximum controller output.")
 
    property("controlled_frame_frame", "std/string" ).
       doc("This is the 'end effector' frame of the controlled motion")

    property("controlled_in_frame", "std/string").
       doc("This is the base frame of the controller motion, e.g. the robot base frame")

    property("setpoint_frame", "std/string").
       doc("This is the setpoint frame of the controller motion, e.g. the control target")

    input_port("kp_values", "base/Vector6d").
       doc("Optional port for online setting new gain values.")

    output_port("ctrl_out", "base/samples/RigidBodyState").
       doc("Controller output (velocity/angular velocity).")
    
    transformer do
      transform 'controlled_in', 'setpoint'
      transform 'controlled_in', 'controlled_frame'
      max_latency 0.1
    end

    # For debugging
    output_port("control_error", "base/samples/RigidBodyState")

    periodic 0.1
end

