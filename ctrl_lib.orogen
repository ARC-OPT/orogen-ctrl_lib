name "ctrl_lib"

import_types_from "base"
using_library "ctrl_lib"

##########################################################################################################
# Repulsive Potential Field method in joint space. One 1-dim. potential field per joint of shape: 
#
#     U = (kp/2) * (1/d - 1/d_0), d <= d_0
#       = 0                     , else
#
#     d = |q-q_0|
#   d_0 = Maximum Influence distance
#   q_0 = Potential field center
#    kp = Proportional gain
#
# Out: acc = vel = -grad(U) = kp * (1/d - 1/d_0) * (q - q_0)/d^2,  d<= d_0
#                           = 0                                 ,  else
#
task_context "JointRepPotField" do
    needs_configuration

    property("q_zero", "base/samples/Joints").
          doc("Potential field center per joint (only position field used)")

    property("d_zero", "base/samples/Joints").
          doc("Maximum influence distance per joint (only position field used)")

    property("pid", "std/vector<base/actuators/PIDValues>").
          doc("PID Gain. I and D values will be ignored. Max PWM will be used as ctrl output saturation.")    
    
    input_port("feedback", "base/samples/Joints").
          doc("Current Joint status")

    output_port("ctrl_out", "base/commands/Joints").
          doc("Output (velocity and effort)")
    
    periodic 0.1
end

##########################################################################################################
# Repulsive Potential Field method in Cartesian space. 3-dim. radial potential field of shape: 
#
#     U = (kp/2) * (1/d - 1/d_0), d <= d_0
#       = 0                       , else
#
#     d = ||x-x_0||
#   d_0 = Maximum Influence distance
#   x_0 = Potential field center
#    kp = Proportional gain
#
# Out: acc = vel = -grad(U) = kp * (1/d - 1/d_0) * (q - q_0)/d^2,  d<= d_0
#                           = 0                                 ,  else
#
task_context "CartRepPotField" do
    needs_configuration

    property("d_zero", "double").
         doc("Maximum influence distance")

    property("pid", "std/vector<base/actuators/PIDValues>").
         doc("PID Gain. Size 3. I and D values will be ignored. Max PWM will be used as ctrl output saturation.")
 
    property("controlled_frame_frame", "std/string").
         doc("This is the 'end effector' frame of the controlled motion")

    property("controlled_in_frame", "std/string").
         doc("This is the base frame of the controller motion, e.g. the robot base frame")

    property("rep_field_center_frame", "std/string").
         doc("This is the rep_field_center frame of the controller motion")

    output_port("ctrl_out", "base/samples/RigidBodyState").
         doc("Gradient of potential field")
    
    transformer do
      transform 'controlled_in', 'rep_field_center'
      transform 'controlled_in', 'controlled_frame'
      max_latency 0.1
    end

    periodic 0.1
end

##########################################################################################################
# Joint PID controller with acceleration feedfoward plus velocity and acceleration saturation
# 
#   vel_out = v_r + kp/kd*(x_r-x) + ki/kd*(sum(x_r-x)), |vel_out| <= max_vel
#   acc_out = a_r + kd*(v_out-v), |acc_out| <= max_acc
#
task_context "JointPIDCtrl" do
    needs_configuration
   
    property("max_ctrl_out", "base/samples/Joints").
         doc("Max velocities and accelerations can be defined here. If left empty, infinite ctrl output will be allowed")

    property("pid", "std/vector<base/actuators/PIDValues>").
         doc("PID Controller parameters, this property will determine the expected number of inputs and outputs!
              Note: The maxPWM entry of pidValues will be used as windup.")

    input_port("setpoint", "base/commands/Joints").
         doc("Reference value for controller. Has to have same size as pid property.")

    input_port("feedback", "base/samples/Joints").
         doc("Current joint state. Has to have same size as pid property.")

    input_port("pid_values", "std/vector<base/actuators/PIDValues>").
         doc("Optional port for online setting new pid values ")
    
    output_port("ctrl_out", "base/commands/Joints").
         doc("Controller output. Will have same size as pid property.")

    periodic 0.1
end

##########################################################################################################

# Cartesian PID controller with acceleration feedfoward, velocity and acceleration saturation
# 
#   vel_out = v_r + kp/kd*(x_r-x) + ki/kd*(sum(x_r-x)), |vel_out| <= max_vel
#   acc_out = a_r + kd*(v_out-v), |acc_out| <= max_acc
#
task_context "CartPIDCtrl" do
    needs_configuration

    property("max_ctrl_out", "base/samples/RigidBodyState").
       doc("Max cartesian velocities and accelerations can be defined here. If left empty, infinite ctrl output will be allowed")

    property("pid", "std/vector<base/actuators/PIDValues>").
       doc("PID Controller parameters. Size has to be 6! Note: The maxPWM entry of pidValues will be used as windup")
 
    property("controlled_frame_frame", "std/string" ).
       doc("This is the 'end effector' frame of the controlled motion")

    property("controlled_in_frame", "std/string").
       doc("This is the base frame of the controller motion, e.g. the robot base frame")

    property("target_frame", "std/string").
       doc("This is the setpoint frame of the controller motion, e.g. the control target")
  
    input_port("pid_values", "std/vector<base/actuators/PIDValues>").
       doc("Optional port for online setting new pid values ")

    output_port("ctrl_out", "base/samples/RigidBodyState").
       doc("Controller output. Will have velocity and acceleration output (see above)")

    transformer do
      transform 'controlled_in', 'setpoint'
      transform 'controlled_in', 'controlled_frame'
      max_latency 0.1
    end

    periodic 0.1
end

##########################################################################################################
