name "ctrl_lib"

using_library "ctrl_lib"
import_types_from "ctrl_libTypes.hpp"
import_types_from "ctrl_lib/ActivationFunction.hpp"
import_types_from "base"
using_library "kdl_conversions"

#
# Base class for all controllers. Implements the controller state machine. Basic functionality is as follows:
#
#  1. Read Feedback term
#  2. If a feedback term is available, read setpoint. Once there is a setpoint, control output will be written at all times. Use reset() to set the
#     current setpoint equal to the feedback term and make the control output zero.
#  3. Compute and write control output, depending on the implementation of the controller (derived task)
#  4. Compute activation. The activation indicates how much influence a control output has, compared to the other control outputs. Activation
#     values will be within 0..1. The activation ports can e.g. be connected to WBC in order to deactivate constraint variables and make unneeded
#     dof available for other tasks. A typical example is Joint limits avoidance. Usually one wants to activate the avoidance behavior only when
#     being close to the joint limits and not disturb other tasks when moving freely. Different activation functions can be chosen (e.g. linear, quadratic, ...)
#     in order to achieve smooth transitions.
#  5. Compute controller performance. Controller dependent performance indicators will be computed and written to port. Use startEvaluation(bool) to start/stop
#     computation of performance values
#
task_context "ControllerTask" do abstract
   needs_configuration

   runtime_states "NO_SETPOINT", # Never got a setpoint, no control output will be written
                  "NO_FEEDBACK"  # Never got feedback, no control output will be written

   # Unique name for each variable, e.g. joint names in case of a joint space controller.
   property("field_names", "std/vector<std/string>")

   # Proportional gain. Size has to be the same as size of field_names.
   property("prop_gain", "base/VectorXd").dynamic

   # Maximum control output (saturation). If one output value exceeds maximum, all
   # other values will be scaled accordingly. Size has to be the same as size of field_names.
   property("max_control_output", "base/VectorXd").dynamic

   # Minimum control error (dead zone). If one control error value falls below this minimum, it will be set to zero.
   property("dead_zone", "base/VectorXd").dynamic

   # Type of activation function used. See ctrl_lib/ActivationFunction.hpp for details.
   property("activation_function", "ctrl_lib/ActivationFunction")


   # Current activation values
   output_port("activation", "base/VectorXd")

   # Debug: Current control error.
   output_port("control_error", "base/VectorXd")

   # Debug: Current max control output.
   output_port("current_max_control_output", "base/VectorXd")

   # Debug: Current dead zone.
   output_port("current_dead_zone", "base/VectorXd")

   # Debug: Current proportional gain
   output_port("current_prop_gain", "base/VectorXd")

   # Control performance. Performance measure that reflects the quality of the control action
   output_port("ctrl_performance", "base/VectorXd")


   # Start/Stop evaluation
   operation("startEvaluation").
       argument("start", "bool")

   # Reset function. Implemented in derived task. This sets the control output to zero by setting setpoint and feedback to the same value.
   operation("reset")


   # The controllers should be called periodically to achieve best performance.
   periodic 0.01
end

#
# Implementation of a proportional position controller in joint space.
#
task_context "JointPositionController" do subclasses "ControllerTask"
   needs_configuration

   # Feed Forward gain. Size has to be the same as size of field_names.
   property("ff_gain", "base/VectorXd").dynamic

   # Debug: Current proportional gain
   output_port("current_ff_gain", "base/VectorXd")

   # Setpoint of the controller. Joints will be mapped by name internally. Size has to be >= size of field_names. All field names have to be present.
   input_port("setpoint", "base/commands/Joints")

   # Feedback term of the controller. Joints will be mapped by name internally. Size has to be >= size of field_names. All field names have to be present.
   input_port("feedback", "base/samples/Joints")

   # Control output as velocity. Size will be same as size of field_names.
   output_port("control_output", "base/commands/Joints")

   # Debug: Current setpoint
   output_port("current_setpoint", "base/commands/Joints")

   # Debug: Current feedback term
   output_port("current_feedback", "base/samples/Joints")

   periodic 0.01
end

#
# Implementation of proportional position controller in Cartesian space. Size of field_names has to be 6. The orientation error will be computed
# using zyx rotation. So the control output will be <velocity(xyz), angular_velocity(zyx)>
# 
task_context "CartesianPositionController" do subclasses "ControllerTask"
   needs_configuration

   # Feed Forward gain. Size has to be the same as size of field_names.
   property("ff_gain", "base/VectorXd").dynamic

   # Debug: Current proportional gain
   output_port("current_ff_gain", "base/VectorXd")

   # Setpoint of the controller.
   input_port("setpoint", "base/samples/RigidBodyState")

   # Feedback term of the controller.
   input_port("feedback", "base/samples/RigidBodyState")

   # Control output as Cartesian velocity/angular velocity.
   output_port("control_output", "base/samples/RigidBodyState")

   # Debug: Current setpoint.
   output_port("current_setpoint", "base/samples/RigidBodyState")

   # Debug: Current feedback term.
   output_port("current_feedback", "base/samples/RigidBodyState")

   periodic 0.01
end

#
# Implementation of a proportional force/torque controller in Cartesian space.
#
task_context "CartesianForceController" do subclasses "ControllerTask"
   needs_configuration

   # Setpoint of the controller
   input_port("setpoint", "base/samples/Wrench")

   # Feedback term of the controller.
   input_port("feedback", "base/samples/Wrench")

   # Control output as Cartesian velocity/angular velocity.
   output_port("control_output", "base/samples/RigidBodyState")

   # Debug: Current setpoint.
   output_port("current_setpoint", "base/samples/Wrench")

   # Debug: Current feedback term.
   output_port("current_feedback", "base/samples/Wrench")

   periodic 0.01
end


#
# Implementation of RadialPotentialFields in joint space. Each joint will have one 1-dimensional potential field.
# See ctrl_lib/RadialPotentialField.hpp and ctrl_lib/PotentialFieldsController.hpp for details
#
task_context "JointLimitAvoidance" do subclasses "ControllerTask"
   needs_configuration

   # Order of all potential fields. If order = 0 => control_output = const,
   # if order = 1 => control_output ~ 1/d. If order = 2, => control_output ~ 1/d^2 and so on.
   property("order", "int", 1)

   # Influence distance of the potential fields. Size has to be the same as size of field_names. Values have to be > 0!
   property("influence_distance", "base/VectorXd").dynamic

   # centers of the potential fields. Size has to be either empty or same as size of field_names
   property("joint_limits", "base/JointLimits")

   # Controller feedback: Actual joint position. Size has to be same as size of field_names. Joints will mapped internally by names.
   # All joints from field_names have to be available here!
   input_port("feedback", "base/samples/Joints")

   # Control output as joint velocity. Size will be same as size of field_names.
   output_port("control_output", "base/commands/Joints")

   # Debug: Current influence distance
   output_port("current_influence_distance", "base/VectorXd")

   # Debug: Current status and settings for all potential fields.
   output_port("field_infos", "std/vector<ctrl_lib/PotentialFieldInfo>")

   # Debug: Current feedback term.
   output_port("current_feedback", "base/samples/Joints")

   periodic 0.01
end

#
# Implementation of RadialPotentialFields in Cartesian space. Dimension of all fields has to be 3! See ctrl_lib/RadialPotentialField.hpp and
# ctrl_lib/PotentialFieldsController.hpp for details
#
task_context "CartesianRadialPotentialFields" do subclasses "ControllerTask"
   needs_configuration

   # Order of all potential fields. If order = 0 => control_output = const,
   # if order = 1 => control_output ~ 1/d. If order = 2, => control_output ~ 1/d^2 and so on.
   property("order", "int", 1)

   # Influence distance of the potential fields. Size has to be the same as size of field_names. Values have to be > 0!
   property("influence_distance", "double").dynamic

   # Set new centers of the potential fields here. Number of fields can be anything > 0.
   input_port("pot_field_centers",  "std/vector<base/samples/RigidBodyState>")

   # Controller feedback: Actual position of the control frame on the robot. Orientation is not used in this controller
   input_port("feedback", "base/samples/RigidBodyState")

   # Control output as cartesian velocity.
   output_port("control_output",   "base/samples/RigidBodyState")

   # Debug: Current max control output.
   output_port("current_influence_distance", "base/VectorXd")

   # Debug: Current status and settings for all potential fields.
   output_port("field_infos", "std/vector<ctrl_lib/PotentialFieldInfo>")

   # Debug: Current feedback term.
   output_port("current_feedback", "base/samples/RigidBodyState")

   periodic 0.01
end

typekit do
   export_types "ctrl_lib/ActivationFunction"
end
