name "ctrl_lib"

using_library "ctrl_lib"
import_types_from "ctrl_libTypes.hpp"
import_types_from "base"

#
# Base task for all controllers
#
task_context "ControllerTask" do abstract
   needs_configuration
   runtime_states "NO_SETPOINT", "NO_FEEDBACK"

   property("fieldNames",       "std/vector<std/string>").doc("Name for each variable, e.g. joint names in case of joint space controller")
   property("propGain",         "base/VectorXd").doc("Proportional gain.")
   property("maxControlOutput", "base/VectorXd").doc("Maximum control output (saturation). If one output value exceeds maximum, all other values will be scaled accordingly. Default is infinite.")
   property("deadZone",         "base/VectorXd").doc("Minimum control error (dead zone). If one value falls below minimum, it will be set to zero. Default is zero.")

   input_port("newPropGain",         "base/VectorXd").doc("Set new proportional gain here.")
   input_port("newMaxControlOutput", "base/VectorXd").doc("Set new maximum control output here.")
   input_port("newDeadZone",         "base/VectorXd").doc("Set new dead zone here.")

   output_port("currentPropGain",         "base/VectorXd").doc("Current proportional gain used")
   output_port("currentMaxControlOutput", "base/VectorXd").doc("Current max ctrl output gain used")
   output_port("currentDeadZone",         "base/VectorXd").doc("Current dead zone used")
   output_port("controlError",            "base/VectorXd").doc("Current control error")
   output_port("controlOutputRaw",        "base/VectorXd").doc("Raw control output")

   periodic 0.01
end

#
# Implementation of PositionControlFeedForward in joint space. See ctrl_lib/PositionControlFeedForward.hpp for details
#
task_context "JointPositionController" do subclasses "ControllerTask"
   needs_configuration

   input_port("setpoint", "base/commands/Joints"  ).doc("Setpoint of the controller. Joints will be mapped internally.")
   input_port("feedback", "base/samples/Joints"   ).doc("Feedback term of the controller.")

   output_port("controlOutput",   "base/commands/Joints").doc("Control output as velocity.")
   output_port("currentFeedback", "base/samples/Joints" ).doc("Current feedback term.")

   periodic 0.01
end

#
# Implementation of PositionControlFeedForward in Cartesian space
# 
task_context "CartesianPositionController" do subclasses "ControllerTask"
   needs_configuration

   input_port("setpoint", "base/samples/RigidBodyState").doc("Setpoint of the controller.")
   input_port("feedback", "base/samples/RigidBodyState").doc("Feedback term of the controller.")

   output_port("controlOutput",   "base/samples/RigidBodyState" ).doc("Control output as velocity.")
   output_port("currentFeedback", "base/samples/RigidBodyState" ).doc("Current feedback term.")

   periodic 0.01
end

#
# Implementation of RadialPotentialFields in joint space. Each joint will have one 1-dimensional potential field.
# See ctrl_lib/RadialPotentialField.hpp and ctrl_lib/MultiPotentialFields1D.hpp for details
#
task_context "JointRadialPotentialFields" do subclasses "ControllerTask"
   needs_configuration

   property("maxInfluenceDistance", "base/VectorXd"          ).doc("Maximum influence distance of the potential fields oer joint. For N joints, this vector has to have size N.")
   property("order",                "double", 1              ).doc("Order of the potential field. If M = 0 controlOutput = const, if M = 1, controlOutput ~ 1/d. If M = 2, controlOutput ~ 1/d^2 and so on.")
   property("potFieldCenters",      "base/commands/Joints"   ).doc("Initial center of the potential fields. For N joints this has to have size N.")

   input_port("newMaxInfluenceDistance", "base/VectorXd"       ).doc("Set new max influence distance here")
   input_port("newOrder",                "double"              ).doc("Set new potential field order here")
   input_port("setpoint",                "base/commands/Joints").doc("Setpoint of the controller. In this case interpreted as new centers of the potential fields.")
   input_port("feedback",                "base/samples/Joints" ).doc("Feedback term of the controller.")
     
   output_port("controlOutput",   "base/commands/Joints").doc("Control output as velocity.")
   output_port("currentFeedback", "base/samples/Joints" ).doc("Current feedback term.")

   periodic 0.01   
end

#
# Implementation of RadialPotentialFields in Cartesian space. Dimension of all fields has to be 3! See ctrl_lib/RadialPotentialField.hpp and
# ctrl_lib/MultiPotentialFields.hpp for details
#
task_context "CartesianRadialPotentialFields" do subclasses "ControllerTask"
   needs_configuration

   property("maxInfluenceDistance", "base/VectorXd"                          ).doc("Maximum influence distance of the potential fields. For N fields, this vector has to have size N!")
   property("order",                "double", 1                              ).doc("Order of the potential field. If M = 0 controlOutput = const, if M = 1, controlOutput ~ 1/d. If M = 2, controlOutput ~ 1/d^2 and so on.")
   property("potFieldCenters",      "std/vector<base/samples/RigidBodyState>").doc("Initial centers of the potential fields. For N fields, this has to have size Nx3")

   input_port("newMaxInfluenceDistance", "base/VectorXd"                          ).doc("Set new max influence distance here")
   input_port("newOrder",                "double"                                 ).doc("Set new potential field order here")
   input_port("setpoint",                "std/vector<base/samples/RigidBodyState>").doc("Setpoint of the controller. In this case interpreted as new centers of the potential fields.")
   input_port("feedback",                "base/samples/RigidBodyState"            ).doc("Feedback term of the controller. Actual pose of the controlled frame.")

   output_port("controlOutput",   "base/samples/RigidBodyState" ).doc("Control output as velocity.")
   output_port("gradients",       "std/vector<base/VectorXd>"   ).doc("Debug output: Gradient for each of the potential fields")
   output_port("currentFeedback", "base/samples/RigidBodyState" ).doc("Current feedback term.")

   periodic 0.01
end

