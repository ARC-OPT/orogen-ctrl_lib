name "ctrl_lib"

import_types_from "base"
using_library "kdl_conversions"

#
# Base for Joint Space controllers
#
task_context "JointController" do
    abstract 

    property "joint_names", "std/vector<std/string>"
    property "max_ctrl_out", "base/VectorXd"
    property "dead_zone", "base/VectorXd"
  
    input_port "setpoint", "base/commands/Joints"
    input_port "feedback", "base/commands/Joints"
    
    output_port "ctrl_out", "base/commands/Joints"
end

#
# Base for Cartesian space controllers
#
task_context "CartController" do
    abstract     

    property "controlled_in_frame",    "std/string"  # This is the base frame of the controller motion, e.g. the robot base frame
    property "setpoint_frame",         "std/string"  # This is the setpoint frame of the controller motion, e.g. the control target
    property "controlled_frame_frame", "std/string"  # This is the 'end effector' frame of the controlled motion

    property "max_ctrl_out", "base/Vector6d"
    property "dead_zone", "base/Vector6d"

    output_port "ctrl_out", "base/samples/RigidBodyState"
    
    transformer do
      transform 'setpoint', 'controlled_in'
      transform 'controlled_frame', 'controlled_in'
      max_latency 0.1
    end
end

#
# Joint Limit avoidance task, creates repulsive velocities near the joint limits:
#
#    ctrl_out = -kp * (d_zero - d)*(d_zero - d),  if |d| <= d_zero
#
#    activation = 1, if |d| < (1-transition_range)*d_zero
#               = ((d_zero - d)*(d_zero - d))/((transition_range * d_zero) * (transition_range * d_zero)), if (1-transition_range)*d_zero < |d| < d_zero
#               = 0, else
#    
#    with |ctrl_out| <= max_ctrl_out
#             d       = Distance to the closest joint limit for one joint
#
task_context "JointLimitAvoidance" do
   needs_configuration
   subclasses "JointController"
   
   property "joint_limits", "base/JointLimits" # Note: Avoidance will be only done for the joints defined in the joint_names property.
   property "d_zero", "base/VectorXd"          # Maximum influence distance per joint. Has to have same size as joint_names.
   property "transition_range", "double"       # Transition range in percentage of the maximum influence distance. Has to be within 0..1.
                                               # Activation function is a piecewise linear function, that increases from 0 to 1.
                                               # The higher this value, the smaller the incline of the activation function.
                                               # For transition_range = 0, the activation will be a step function.
   property "kp", "base/VectorXd"              # Proportional gain. Has to have same size as joint_names property.

   input_port "kp_values",   "base/VectorXd"   # Proportional gain. This port can be used for adaptive control. 
   output_port "activation", "base/VectorXd"   # Activation function. Will be between 0 and 1 for each joint.    

   port_driven "feedback"
end

#
# Joint PD-controller with velocity and acceleration feedfoward term:
# 
#   ctrl_out(vel) = kd * v_r + kp * (x_r-x)
#   ctrl_out(acc) = a_r + kd * (v_r - v) + kp * (x_r-x)
#
#      with  |ctrl_out| <= max_ctrl_out
#              x_r, x    = Position Setpoint and Actual position
#              v_r, v    = Velocity Setpoint and Actual velocity
#              a_r       = Acceleration Setpoint 
#
task_context "JointPosCtrlVelFF" do
   subclasses "JointController"
   needs_configuration

   property "kp", "base/VectorXd" # Proportional gain. Has to have same size as joint_names property.
   property "kd", "base/VectorXd" # Differential gain. Has to have same size as joint_names property.

   input_port "kp_values", "base/VectorXd"   # Proportional gain. This port can be used for adaptive control. 
   input_port "kd_values", "base/VectorXd"   # Differential gain. This port can be used for adaptive control. 

   periodic 0.1
end


#
# Cartesian PD-controller with velocity feedforward term. Ctrl output will be given
# wrt. controlled_in_frame
# 
#   ctrl_out(vel) = kd * v_r + kp * (x_r-x)
#
#      with  |ctrl_out| <= max_ctrl_out
#              x_r, x    = Pose Setpoint and Actual pose
#              v_r       = Twist Setpoint and Actual twist
#
task_context "CartPosCtrlVelFF" do
    subclasses "CartController"
    needs_configuration

    property "kp", "base/Vector6d" # Proportional controller parameters. 
    property "kd", "base/Vector6d" # Differential controller parameters. 

    input_port "kp_values", "base/Vector6d" # Proportional gain. This port can be used for adaptive control. 
    input_port "kd_values", "base/Vector6d" # Differential gain. This port can be used for adaptive control. 

    periodic 0.1
end

#
# Simple Cartesian Force Controller with velocity output. 
# Note: Input wrench will be transformed
# from "controlled_frame_frame" to "controlled_in_frame", input wrench_ref will be transformed
# from "setpoint_frame" to "controlled_in_frame". Ctrl_out will be given in controlled_in_frame
#
#    ctrl_out = kp * (wrench_ref - wrench)
#  
#     |ctrl_out| <= max_ctrl_out
#
task_context "CartForceCtrlSimple" do    
    subclasses "CartController" 
    needs_configuration

    property "kp", "base/Vector6d" # Proportional controller parameters.
   
    input_port "kp_values", "base/Vector6d"        # Proportional gain. This port can be used for adaptive control. 
    input_port "wrench_ref", "base/samples/Wrench" # Reference wrench
    input_port "wrench", "base/samples/Wrench"     # Reference wrench

    output_port "activation", "base/VectorXd" # Entries will be 1 in case there is a control output for that variable, or 0

    periodic 0.1
end

# Gaze Controller for e.g. AILA's pan-tilt unit. Temporary hack until we 
# fixed the problem with the twist computation of the fourlink joint
task_context "CartGazeCtrl" do
    needs_configuration

    property("joint_names", "std/vector<std/string>").
       doc("Joint Names.")

    property("kp", "base/Vector2d").
       doc("Proportional controller parameters.")

    property("max_ctrl_out", "base/Vector2d").
       doc("Maximum controller output.")

    property("timeout", "double").
       doc("In Seconds. Bring back the to the configure default setpoint after this amount of time. If this is nan, don`t use timeout.")

    property("default_setpoint", "base/samples/RigidBodyState").
       doc("Will be set as setpoint in case of timeout. Expressed in 'controlled_in_frame'.")

    property("controlled_in_frame", "std/string").
       doc("This is the base frame of the controller motion, e.g. the robot's camera frame")

    property("setpoint_frame", "std/string").
       doc("This is the setpoint frame of the controller motion, e.g. the control target")

    output_port("ctrl_out", "base/commands/Joints").
       doc("Controller output (angular velocity).")
       
    input_port("joint_state", "base/samples/Joints")
    
    transformer do
      transform 'setpoint', 'controlled_in'
      max_latency 0.1
    end

    periodic 0.1
end

