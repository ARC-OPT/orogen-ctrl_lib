name "ctrl_lib"

using_library "ctrl_lib"
import_types_from "ctrl_libTypes.hpp"
import_types_from "base"
using_library "kdl_conversions"

#
# Base task for all proportional controllers. See ctrl_lib/ProportionalController.hpp for details
#
task_context "ProportionalControllerTask" do abstract
   needs_configuration

   runtime_states "NO_SETPOINT", # Never got a setpoint, no control output will be written
                  "NO_FEEDBACK"  # Never got feedback, no control output will be written

   # Unique name for each variable, e.g. joint names in case of a joint space controller.
   property "field_names", "std/vector<std/string>"

   # Proportional gain. Size has to be the same as size of field_names.
   property "initial_prop_gain", "base/VectorXd"

   # Maximum control output (saturation). If one output value exceeds maximum, all
   # other values will be scaled accordingly. Size has to be the same as size of field_names.
   property "initial_max_control_output", "base/VectorXd"

   # Minimum control error (dead zone). If one control error value falls below this minimum, it will be set to zero.
   property "initial_dead_zone", "base/VectorXd"

   # Set new proportional gain here. Size has to be the same as size of field_names.
   input_port "prop_gain", "base/VectorXd"

   # Set new maximum control output here. Size has to be the same as size of field_names.
   input_port "max_control_output", "base/VectorXd"

   # Set new dead zone here. Size has to be the same as size of field_names.
   input_port "dead_zone", "base/VectorXd"

   # Debug: Current control error.
   output_port "control_error", "base/VectorXd"

   # Debug: Current proportional gain
   output_port "current_prop_gain", "base/VectorXd"

   # Debug: Current max control output.
   output_port "current_max_control_output", "base/VectorXd"

   # Debug: Current dead zone.
   output_port "current_dead_zone", "base/VectorXd"

   # Set setpoint to current feedback value
   operation "reset"

   periodic 0.01
end

#
# Implementation of a proportional position controller in joint space.
#
task_context "JointPositionController" do subclasses "ProportionalControllerTask"
   needs_configuration

   # Setpoint of the controller. Joints will be mapped by name internally. Size has to be >= size of field_names. All field names have to be present.
   input_port "setpoint", "base/commands/Joints"

   # Feedback term of the controller. Joints will be mapped by name internally. Size has to be >= size of field_names. All field names have to be present.
   input_port "feedback", "base/samples/Joints"

   # Control output as velocity. Size will be same as size of field_names.
   output_port "control_output", "base/commands/Joints"

   # Debug: Current setpoint.
   output_port "current_setpoint", "base/commands/Joints"

   # Debug: Current feedback term.
   output_port "current_feedback", "base/samples/Joints"

   periodic 0.01
end

#
# Implementation of proportional position controller in Cartesian space. Size of field_names has to be 6. The orientation error will be computed
# using zyx rotation. So the control output will be <velocity(xyz), angular_velocity(zyx)>
# 
task_context "CartesianPositionController" do subclasses "ProportionalControllerTask"
   needs_configuration

   # Setpoint of the controller.
   input_port "setpoint", "base/samples/RigidBodyState"

   # Feedback term of the controller.
   input_port "feedback", "base/samples/RigidBodyState"

   # Control output as Cartesian velocity/angular velocity.
   output_port "control_output", "base/samples/RigidBodyState"

   # Debug: Current setpoint.
   output_port "current_setpoint", "base/samples/RigidBodyState"

   # Debug: Current feedback term.
   output_port "current_feedback", "base/samples/RigidBodyState"

   periodic 0.01
end

#
# Implementation of a proportioanl force/torque controller in Cartesian space.
#
task_context "CartesianForceController" do subclasses "ProportionalControllerTask"
   needs_configuration

   # Setpoint of the controller
   input_port "setpoint", "base/samples/Wrench"

   # Feedback term of the controller.
   input_port "feedback", "base/samples/Wrench"

   # Control output as Cartesian velocity/angular velocity.
   output_port "control_output", "base/samples/RigidBodyState"

   # Debug: Current setpoint.
   output_port "current_setpoint", "base/samples/Wrench"

   # Debug: Current feedback term.
   output_port "current_feedback", "base/samples/Wrench"
end

#
# Base task for all potential fields. See ctrl_lib/PotentialFieldsController.hpp for details
#
task_context "PotentialFieldsControllerTask" do abstract

   runtime_states "NO_POSITION",         # Never got current position, no control output will be written
                  "NO_POT_FIELD_CENTERS" # Never got field positions, no control output will be written

   # Name for each variable, e.g. joint names in case of a joint space controller.
   property "field_names", "std/vector<std/string>"

   # Order of all potential fields. If order = 0 => control_output = const,
   # if order = 1 => control_output ~ 1/d. If order = 2, => control_output ~ 1/d^2 and so on.
   property "order", "int", 1

   # Initial proportional gain. Size has to be the same as size of field_names.
   property "initial_prop_gain", "base/VectorXd"

   # Initial maximum control output (saturation). If one output value exceeds maximum, all other
   # values will be scaled accordingly. Size has to be same as field_names.
   property "initial_max_control_output", "base/VectorXd"

   # Set new proportional gain here. Size has to be the same as size of field_names.
   input_port "prop_gain", "base/VectorXd"

   # Set new maximum control output here. Size has to be the same as size of field_names.
   input_port "max_control_output", "base/VectorXd"

   # Debug: Current control error.
   output_port "current_prop_gain", "base/VectorXd"

   # Debug: Current max control output.
   output_port "current_max_control_output", "base/VectorXd"

   # Debug: Current status and settings for all potential fields.
   output_port "field_infos", "std/vector<ctrl_lib/PotentialFieldInfo>"

   periodic 0.01
end

#
# Implementation of RadialPotentialFields in joint space. Each joint will have one 1-dimensional potential field.
# This implementation can be used, e.g. for joint limit avoidance
# See ctrl_lib/RadialPotentialField.hpp and ctrl_lib/PotentialFieldsController.hpp for details
#
task_context "JointRadialPotentialFields" do subclasses "PotentialFieldsControllerTask"
   needs_configuration

   # Initial centers of the potential fields. Size has to be either empty or same as size of field_names. If empty the task will be wait for input from port
   property "initial_pot_field_centers",  "base/commands/Joints"

   # Influence distance of the potential fields. Size has to be the same as size of field_names. Values have to be > 0!
   property "initial_influence_distance", "base/VectorXd"

   # Set new centers of the potential fields here. Joints will mapped internally by names. All joints from field_names have to be present here!
   input_port "pot_field_centers",  "base/commands/Joints"

   # Controller feedback: Actual joint position. Size has to be same as size of field_names. Joints will mapped internally by names. All joints from field_names have to be present here!
   input_port "feedback",           "base/samples/Joints"

   # Set new influence distance zone here. Size has to be same as size of field_names.
   input_port "influence_distance", "base/VectorXd"
     
   # Control output as joint velocity. Size will be same as size of field_names.
   output_port "control_output",   "base/commands/Joints"

   # Debug: Current position.
   output_port "current_feedback", "base/samples/Joints"

   periodic 0.01
end

#
# Implementation of RadialPotentialFields in Cartesian space. Dimension of all fields has to be 3! See ctrl_lib/RadialPotentialField.hpp and
# ctrl_lib/PotentialFieldsController.hpp for details
#
task_context "CartesianRadialPotentialFields" do subclasses "PotentialFieldsControllerTask"
   needs_configuration

   # Influence distance. This will be same for all pot. fields, since the number of fields is dynamic. Value has to be > 0!
   property "initial_influence_distance", "double"

   # Set new centers of the potential fields here. Number of fields can be anything > 0.
   input_port "pot_field_centers",  "std/vector<base/samples/RigidBodyState>"

   # Controller feedback: Actual position of the control frame on the robot. Orientation is not used in this controller
   input_port "feedback",           "base/samples/RigidBodyState"

   # Set new influence distance zone here. Value has to be > 0!
   input_port "influence_distance", "double"

   # Control output as cartesian velocity.
   output_port "control_output",   "base/samples/RigidBodyState"

   # Debug: Current position.
   output_port "current_feedback", "base/samples/RigidBodyState"

   periodic 0.01
end

