name "ctrl_lib"

import_types_from "base"
using_library "kdl_conversions"

#
# Joint Limit avoidance task, creates repulsive velocities near the joint limits:
#
#    ctrl_out = -kp * (d_zero - d)*(d_zero - d),  if |d| <= d_zero
#
#    activation = 1, if |d| < (1-transition_range)*d_zero
#               = ((d_zero - d)*(d_zero - d))/((transition_range * d_zero) * (transition_range * d_zero)), if (1-transition_range)*d_zero < |d| < d_zero
#               = 0, else
#    
#    with |ctrl_out| <= max_ctrl_out
#             d       = Distance to the closest joint limit for one joint
#
task_context "JointLimitAvoidance" do
   needs_configuration

   property( "joint_limits",     "base/JointLimits" ).doc( "Joint Limits. Defines the names of the joints used for control." )
   property( "max_ctrl_out",     "base/VectorXd"    ).doc( "Maximum controller output(saturation). Size has to be same as joint limits." )
   property( "dead_zone",        "base/VectorXd"    ).doc( "If control error is below this value, there will be zero control output for that variable." )
   property( "d_zero",           "base/VectorXd"    ).doc( "Maximum influence distance per joint. Has to have same size as joint_names." )
   property( "kp",               "base/VectorXd"    ).doc( "Proportional gain. Has to have same size as joint_names property." )
   property( "transition_range", "double"           ).doc( "Transition range in percentage of the maximum influence distance. Has to be within 0..1.
                                                            Activation function is a piecewise linear function, that increases from 0 to 1.
                                                            The higher this value, the smaller the incline of the activation function.
                                                            For transition_range = 0, the activation will be a step function." )

   input_port( "setpoint",  "base/commands/Joints" ).doc( "Controller reference. There will ne no control output if no setpoint is given" )
   input_port( "feedback",  "base/commands/Joints" ).doc( "Controller feedback. There will ne no control output if no feedback is given" )
   input_port( "kp_values", "base/VectorXd"        ).doc( "Proportional gain. This port can be used for adaptive control." )

   output_port( "activation", "base/VectorXd"        ).doc( "Activation function. Will be between 0 and 1 for each joint." )
   output_port( "ctrl_out",   "base/commands/Joints" ).doc( "Controller output. Will contain same joints as in joint limits" )

   port_driven "feedback"
end

#
# Joint PD-controller with velocity and acceleration feedfoward term:
# 
#   ctrl_out(vel) = kd * v_r + kp * (x_r-x)
#   ctrl_out(acc) = a_r + kd * (v_r - v) + kp * (x_r-x)
#
#      with  |ctrl_out| <= max_ctrl_out
#              x_r, x    = Position Setpoint and Actual position
#              v_r, v    = Velocity Setpoint and Actual velocity
#              a_r       = Acceleration Setpoint 
#
task_context "JointPosCtrlVelFF" do
   needs_configuration

   property( "joint_names",  "std/vector<std/string>" ).doc( "Joint name vector. Determines the joints used in this controller" )
   property( "max_ctrl_out", "base/VectorXd"          ).doc( "Maximum controller output(saturation). Size has to be same as joint limits." )
   property( "dead_zone",    "base/VectorXd"          ).doc( "If control error is below this value, there will be zero control output for that variable." )
   property( "kp",           "base/VectorXd"          ).doc( "Proportional gain. Has to have same size as joint_names property." )
   property( "kd",           "base/VectorXd"          ).doc( "Differential gain. Has to have same size as joint_names property." )

   input_port( "setpoint",  "base/commands/Joints" ).doc( "Controller reference. There will ne no control output if no setpoint is given" )
   input_port( "feedback",  "base/commands/Joints" ).doc( "Controller feedback. There will ne no control output if no feedback is given" )
   input_port( "kp_values", "base/VectorXd"        ).doc( "Proportional gain. This port can be used for adaptive control." )
   input_port( "kd_values", "base/VectorXd"        ).doc( "Differential gain. This port can be used for adaptive control." )

   output_port( "ctrl_out", "base/commands/Joints" ).doc( "Controller output. Will contain same joints as in joint limits" )

   periodic 0.1
end


#
# Cartesian PD-controller with velocity feedforward term. Ctrl output will be given
# wrt. controlled_in_frame
# 
#   ctrl_out(vel) = kd * v_r + kp * (x_r-x)
#
#      with  |ctrl_out| <= max_ctrl_out
#              x_r, x    = Pose Setpoint and Actual pose
#              v_r       = Twist Setpoint and Actual twist
#
task_context "CartPosCtrlVelFF" do
    needs_configuration

    property( "controlled_in_frame",    "std/string"    ).doc( "This is the base frame of the controller motion, e.g. the robot base frame" )
    property( "setpoint_frame",         "std/string"    ).doc( "This is the setpoint frame of the controller motion, e.g. the control target" )
    property( "controlled_frame_frame", "std/string"    ).doc( "This is the 'end effector' frame of the controlled motion" )
    property( "max_ctrl_out",           "base/Vector6d" ).doc( "Maximum Controller output(saturation)" )
    property( "dead_zone",              "base/Vector6d" ).doc( "If control error is below this value, there will be zero control output for that variable." )
    property( "kp",                     "base/Vector6d" ).doc( "Proportional controller parameters." )
    property( "kd",                     "base/Vector6d" ).doc( "Differential controller parameters." )

    input_port( "kp_values", "base/Vector6d" ).doc( "Proportional gain. This port can be used for adaptive control." )
    input_port( "kd_values", "base/Vector6d" ).doc( "Differential gain. This port can be used for adaptive control." )

    output_port( "ctrl_out", "base/samples/RigidBodyState" ).doc( "Controller output." )

    transformer do
      transform 'setpoint', 'controlled_in'
      transform 'controlled_frame', 'controlled_in'
      max_latency 0.1
    end

    periodic 0.1
end

#
# Simple Cartesian Force Controller with velocity output. 
# Note: Input wrench will be transformed
# from "controlled_frame_frame" to "controlled_in_frame", input wrench_ref will be transformed
# from "setpoint_frame" to "controlled_in_frame". Ctrl_out will be given in controlled_in_frame
#
#    ctrl_out = kp * (wrench_ref - wrench)
#  
#     |ctrl_out| <= max_ctrl_out
#
task_context "CartForceCtrlSimple" do
    needs_configuration

    property( "controlled_in_frame",    "std/string"    ).doc( "This is the base frame of the controller motion, e.g. the robot base frame" )
    property( "setpoint_frame",         "std/string"    ).doc( "This is the setpoint frame of the controller motion, e.g. the control target" )
    property( "controlled_frame_frame", "std/string"    ).doc( "This is the 'end effector' frame of the controlled motion" )
    property( "max_ctrl_out",           "base/Vector6d" ).doc( "Maximum Controller output(saturation)" )
    property( "dead_zone",              "base/Vector6d" ).doc( "If control error is below this value, there will be zero control output for that variable." )
    property( "kp",                     "base/Vector6d" ).doc( "Proportional controller parameters." )
   
    input_port( "kp_values",  "base/Vector6d"        ).doc( "Proportional gain. This port can be used for adaptive control." )
    input_port( "wrench_ref", "base/samples/Wrench"  ).doc( "Reference wrench" )
    input_port( "wrench",     "base/samples/Wrench"  ).doc( "Reference wrench" )

    output_port( "activation", "base/VectorXd"               ).doc( "Entries will be 1 in case there is a control output for that variable, or 0" )
    output_port( "ctrl_out",   "base/samples/RigidBodyState" ).doc( "Controller output." )

    transformer do
      transform 'setpoint', 'controlled_in'
      transform 'controlled_frame', 'controlled_in'
      max_latency 0.1
    end

    periodic 0.1
end

# Gaze Controller for e.g. AILA's pan-tilt unit. Temporary hack until we 
# fixed the problem with the twist computation of the fourlink joint
task_context "CartGazeCtrl" do
    needs_configuration

    property("joint_names", "std/vector<std/string>").
       doc("Joint Names.")

    property("kp", "base/Vector2d").
       doc("Proportional controller parameters.")

    property("max_ctrl_out", "base/Vector2d").
       doc("Maximum controller output.")

    property("timeout", "double").
       doc("In Seconds. Bring back the to the configure default setpoint after this amount of time. If this is nan, don`t use timeout.")

    property("default_setpoint", "base/samples/RigidBodyState").
       doc("Will be set as setpoint in case of timeout. Expressed in 'controlled_in_frame'.")

    property("controlled_in_frame", "std/string").
       doc("This is the base frame of the controller motion, e.g. the robot's camera frame")

    property("setpoint_frame", "std/string").
       doc("This is the setpoint frame of the controller motion, e.g. the control target")

    output_port("ctrl_out", "base/commands/Joints").
       doc("Controller output (angular velocity).")
       
    input_port("joint_state", "base/samples/Joints")
    
    transformer do
      transform 'setpoint', 'controlled_in'
      max_latency 0.1
    end

    periodic 0.1
end

