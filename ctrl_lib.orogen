name "ctrl_lib"

using_library "ctrl_lib"
import_types_from "ctrl_libTypes.hpp"
import_types_from "base"

#
# Base task for all controllers
#
task_context "ControllerTask" do abstract
   needs_configuration
   runtime_states "NO_SETPOINT", "NO_FEEDBACK"

   property("propGain",         "base/VectorXd").doc("Proportional gain.")
   property("maxControlOutput", "base/VectorXd").doc("Maximum control output (saturation). If one output value exceeds maximum, all other values will be scaled accordingly. Default is infinite.")
   property("deadZone",         "base/VectorXd").doc("Minimum control error (dead zone). If one value falls below minimum, it will be set to zero. Default is zero.")

   input_port("newPropGain",         "base/VectorXd").doc("Set new proportional gain here.")
   input_port("newMaxControlOutput", "base/VectorXd").doc("Set new maximum control output here.")
   input_port("newDeadZone",         "base/VectorXd").doc("Set new dead zone here.")

   output_port("controlError",     "base/VectorXd").doc("Current control error")
   output_port("controlOutputRaw", "base/VectorXd").doc("Raw control output")

   periodic 0.01
end

#
# Implementation of PositionControlFeedForward in joint space. See ctrl_lib/PositionControlFeedForward.hpp for details
#
task_context "JointPositionController" do subclasses "ControllerTask"
   needs_configuration

   property("jointNames", "std/vector<std/string>").doc("Joints used by this controller (in this order)")

   input_port("setpoint", "base/commands/Joints"  ).doc("Setpoint of the controller. Joints will be mapped internally.")
   input_port("feedback", "base/samples/Joints"   ).doc("Feedback term of the controller.")

   output_port("ctrlOutput", "base/commands/Joints").doc("Control output.")

   periodic 0.01
end

#
# Implementation of PositionControlFeedForward in Cartesian space
# 
task_context "CartesianPositionController" do subclasses "ControllerTask"
   needs_configuration

   input_port("setpoint", "base/samples/RigidBodyState").doc("Setpoint of the controller.")
   input_port("feedback", "base/samples/RigidBodyState").doc("Feedback term of the controller.")

   output_port("ctrlOutput", "base/samples/RigidBodyState").doc("Control output.")

   periodic 0.01
end

#
# Implementation of RadialPotentialFields in joint space. Each joint will have one 1-dimensional potential field.
# See ctrl_lib/RadialPotentialField.hpp and ctrl_lib/MultiPotentialFields.hpp for details
#
task_context "JointRadialPotentialFields" do subclasses "ControllerTask"
   needs_configuration

   property("maxInfluenceDistance", "base/VectorXd"            ).doc("Maximum influence distance of the potential fields oer joint. For N joints, this vector has to have size N.")
   property("order",                "double", 1                ).doc("Order of the potential field. If M = 0 y = const, if M = 1, grad ~ 1/d. If M = 2, grad ~ 1/d^2 and so on.")
   property("potFieldCenters",      "std/vector<base/VectorXd>").doc("Initial center of the potential fields. For N joints this has to have size NxM, where M can be 1 or 2.")
   property("jointNames",           "std/vector<std/string>"   ).doc("Joints used by this controller (in this order).")

   input_port("setpoint", "base/commands/Joints").doc("Setpoint of the controller. In this case interpreted as new centers of the potential fields.")
   input_port("feedback", "base/samples/Joints" ).doc("Feedback term of the controller.")
     
   output_port("ctrlOutput", "base/commands/Joints").doc("Control output as velocity. Value will be NaN if outside influence distance of potential field.")

   periodic 0.01   
end

#
# Implementation of RadialPotentialFields in Cartesian space. Dimension of all fields has to be 3! See ctrl_lib/RadialPotentialField.hpp and
# ctrl_lib/MultiPotentialFields.hpp for details
#
task_context "CartesianRadialPotentialFields" do subclasses "ControllerTask"
   needs_configuration

   property("maxInfluenceDistance", "base/VectorXd"            ).doc("Maximum influence distance of the potential fields. For N fields, this vector has to have size N!")
   property("order",                "double", 1                ).doc("Order of the potential field. If M = 0 y = const, if M = 1, grad ~ 1/d. If M = 2, grad ~ 1/d^2 and so on.")
   property("potFieldCenters",      "std/vector<base/VectorXd>").doc("Initial centers of the potential fields. For N fields, this has to have size Nx3")

   input_port("setpoint", "std/vector<base/samples/RigidBodyState>").doc("Setpoint of the controller. In this case interpreted as new centers of the potential fields.")
   input_port("feedback", "base/samples/RigidBodyState"            ).doc("Feedback term of the controller.")

   output_port("ctrlOutput", "base/samples/RigidBodyState").doc("Control output.")

   periodic 0.01
end

