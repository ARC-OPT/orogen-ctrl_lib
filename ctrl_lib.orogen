name "ctrl_lib"

import_types_from "base"
import_types_from "ctrl_libTypes.hpp"
using_library "kdl_conversions"
using_library "kdl_parser"

#
# Joint Limit avoidance task, creates repulsive velocities near the joint limits:
#
#    ctrl_out = -kp * (d_zero - d)*(d_zero - d),  if |d| <= d_zero
#
#    activation = 1, if |d| < (1-transition_range)*d_zero
#               = ((d_zero - d)*(d_zero - d))/((transition_range * d_zero) * (transition_range * d_zero)), if (1-transition_range)*d_zero < |d| < d_zero
#               = 0, else
#    
#    with |ctrl_out| <= max_ctrl_out
#             d       = Distance to the closest joint limit for one joint
#
task_context "JointLimitAvoidance" do
   needs_configuration

   property( "joint_limits",     "base/JointLimits" ).doc( "Joint Limits. Defines the names of the joints used for control." )
   property( "max_ctrl_out",     "base/VectorXd"    ).doc( "Maximum controller output(saturation). Size has to be same as joint limits." )
   property( "d_zero",           "base/VectorXd"    ).doc( "Maximum influence distance per joint. Has to have same size as joint_names." )
   property( "kp",               "base/VectorXd"    ).doc( "Proportional gain. Has to have same size as joint_names property." )
   property( "transition_range", "double"           ).doc( "Transition range in percentage of the maximum influence distance. Has to be within 0..1.
                                                            Activation function is a piecewise linear function, that increases from 0 to 1.
                                                            The higher this value, the smaller the incline of the activation function.
                                                            For transition_range = 0, the activation will be a step function." )

   input_port( "setpoint",  "base/commands/Joints" ).doc( "Controller reference. There will ne no control output if no setpoint is given" )
   input_port( "feedback",  "base/commands/Joints" ).doc( "Controller feedback. There will ne no control output if no feedback is given" )
   input_port( "kp_values", "base/VectorXd"        ).doc( "Proportional gain. This port can be used for adaptive control." )

   output_port( "activation", "base/VectorXd"        ).doc( "Activation function. Will be between 0 and 1 for each joint." )
   output_port( "ctrl_out",   "base/commands/Joints" ).doc( "Controller output. Will contain same joints as in joint limits" )

   port_driven "feedback"
end

#
# Joint PD-controller with velocity and acceleration feedfoward term:
# 
#   ctrl_out(vel) = kd * v_r + kp * (x_r-x)
#   ctrl_out(acc) = a_r + kd * (v_r - v) + kp * (x_r-x)
#
#      with  |ctrl_out| <= max_ctrl_out
#              x_r, x    = Position Setpoint and Actual position
#              v_r, v    = Velocity Setpoint and Actual velocity
#              a_r       = Acceleration Setpoint 
#
task_context "JointPosCtrlVelFF" do
   needs_configuration

   property( "joint_names",  "std/vector<std/string>" ).doc( "Joint name vector. Determines the joints used in this controller" )
   property( "max_ctrl_out", "base/VectorXd"          ).doc( "Maximum controller output(saturation). Size has to be same as joint limits." )
   property( "dead_zone",    "base/VectorXd"          ).doc( "If control error is below this value, there will be zero control output for that variable." )
   property( "kp",           "base/VectorXd"          ).doc( "Proportional gain. Has to have same size as joint_names property." )
   property( "kd",           "base/VectorXd"          ).doc( "Differential gain. Has to have same size as joint_names property." )

   input_port( "setpoint",  "base/commands/Joints" ).doc( "Controller reference. There will ne no control output if no setpoint is given" )
   input_port( "feedback",  "base/commands/Joints" ).doc( "Controller feedback. There will ne no control output if no feedback is given" )
   input_port( "kp_values", "base/VectorXd"        ).doc( "Proportional gain. This port can be used for adaptive control." )
   input_port( "kd_values", "base/VectorXd"        ).doc( "Differential gain. This port can be used for adaptive control." )

   output_port( "ctrl_out", "base/commands/Joints" ).doc( "Controller output. Will contain same joints as in joint limits" )

   periodic 0.1
end


#
# Cartesian PD-controller with velocity feedforward term. Ctrl output will be given
# wrt. controlled_in_frame
# 
#   ctrl_out(vel) = kd * v_r + kp * (x_r-x)
#
#      with  |ctrl_out| <= max_ctrl_out
#              x_r, x    = Pose Setpoint and Actual pose
#              v_r       = Twist Setpoint and Actual twist
#
task_context "CartPosCtrlVelFF" do
    needs_configuration

    property( "controlled_in_frame",    "std/string"    ).doc( "This is the base frame of the controller motion, e.g. the robot base frame" )
    property( "setpoint_frame",         "std/string"    ).doc( "This is the setpoint frame of the controller motion, e.g. the control target" )
    property( "controlled_frame_frame", "std/string"    ).doc( "This is the 'end effector' frame of the controlled motion" )
    property( "max_ctrl_out",           "base/Vector6d" ).doc( "Maximum Controller output(saturation)" )
    property( "dead_zone",              "base/Vector6d" ).doc( "If control error is below this value, there will be zero control output for that variable." )
    property( "kp",                     "base/Vector6d" ).doc( "Proportional controller parameters." )
    property( "kd",                     "base/Vector6d" ).doc( "Differential controller parameters." )

    input_port( "kp_values", "base/Vector6d" ).doc( "Proportional gain. This port can be used for adaptive control." )
    input_port( "kd_values", "base/Vector6d" ).doc( "Differential gain. This port can be used for adaptive control." )

    output_port( "ctrl_out", "base/samples/RigidBodyState" ).doc( "Controller output." )

    transformer do
      transform 'setpoint', 'controlled_in'
      transform 'controlled_frame', 'controlled_in'
      max_latency 0.1
    end

    periodic 0.1
end

#
# Simple Cartesian Force Controller with velocity output. 
# Note: Input wrench will be transformed
# from "controlled_frame_frame" to "controlled_in_frame", input wrench_ref will be transformed
# from "setpoint_frame" to "controlled_in_frame". Ctrl_out will be given in controlled_in_frame
#
#    ctrl_out = kp * (wrench_ref - wrench)
#  
#     |ctrl_out| <= max_ctrl_out
#
task_context "CartForceCtrlSimple" do
    needs_configuration

    property( "controlled_in_frame",    "std/string"    ).doc( "This is the base frame of the controller motion, e.g. the robot base frame" )
    property( "setpoint_frame",         "std/string"    ).doc( "This is the setpoint frame of the controller motion, e.g. the control target" )
    property( "controlled_frame_frame", "std/string"    ).doc( "This is the 'end effector' frame of the controlled motion" )
    property( "max_ctrl_out",           "base/Vector6d" ).doc( "Maximum Controller output(saturation)" )
    property( "dead_zone",              "base/Vector6d" ).doc( "If control error is below this value, there will be zero control output for that variable." )
    property( "kp",                     "base/Vector6d" ).doc( "Proportional controller parameters." )
   
    input_port( "kp_values",  "base/Vector6d"        ).doc( "Proportional gain. This port can be used for adaptive control." )
    input_port( "wrench_ref", "base/samples/Wrench"  ).doc( "Reference wrench" )
    input_port( "wrench",     "base/samples/Wrench"  ).doc( "Reference wrench" )

    output_port( "activation", "base/VectorXd"               ).doc( "Entries will be 1 in case there is a control output for that variable, or 0" )
    output_port( "ctrl_out",   "base/samples/RigidBodyState" ).doc( "Controller output." )

    transformer do
      transform 'setpoint', 'controlled_in'
      transform 'controlled_frame', 'controlled_in'
      max_latency 0.1
    end

    periodic 0.1
end

#
# Outputs the gradient of the manipulability measure in joint space grad m = kp * (d/dq)( sqrt(det(J*J_T)) ), where J is the Jacobian associated with
# the frames controlled_in_frame (root) and controlled_frame_frame (tip)
#
task_context "ManipulabilityGradientCtrl" do
    needs_configuration
 
    property( "urdf",                   "std/string"   ).doc( "Path to urdf model")
    property( "controlled_in_frame",    "std/string"   ).doc( "This is the base frame of the controller motion, e.g. the robot base frame" )
    property( "controlled_frame_frame", "std/string"   ).doc( "This is the 'end effector' frame of the controlled motion" )
    property( "delta_q",                "double"       ).doc( "Joint angle delta used for computing the gradient of the manipulability function" )
    property( "kp",                     "base/VectorXd").doc( "Proportional gain vector. Has to have same size as number of joints in kinematic chain" )
     
    input_port( "joint_state", "base/samples/Joints").doc( "Current joint state upon which the Jacobian are computed")

    output_port( "ctrl_out", "base/commands/Joints").doc( "Controller output" ) 
    output_port( "sample_time", "double").doc( "Computation time for on control cycle" )
    output_port( "manipulability", "double").doc( "Manipulability index for the current configuration" )

    periodic 0.1
end

#
# To be used as gaze controller for a pan tilt unit. Used to control the orientation of camera_frame, so that
# the camera_axis points to a certain object in space, expressed by object_frame.
#
task_context "CartGazeCtrl" do
    needs_configuration
    runtime_states 'NO_OBJECT_TRANSFORM'

    property("kp", "base/Vector3d").
       doc("Proportional controller parameters. Only the axes that are NOT defined as camera axis are used to control the orientation of the camera frame")

    property("max_ctrl_out", "base/Vector3d").
       doc("Maximum controller output.")

    property("dead_zone", "base/Vector3d").
       doc("If control error is below this value, don't do anything.")

    #property("camera_axis", "ctrl_lib/camera_axis", :z_axis).
    #   doc("Define the camera optical axis")

    property("camera_frame", "std/string").
       doc("Name of the camera frame")

    property("object_frame", "std/string").
       doc("Name of the object frame the camera should point at")

    property("detection_timeout", "double", 0.2).
       doc("If no new object pose arrives for this amount of time, the object is assumed to be lost and the control output is set to zero")

    output_port("ctrl_out", "base/samples/RigidBodyState").
       doc("Controller output.")

    transformer do
      transform 'object', 'camera'
      max_latency 0.1
    end

    periodic 0.1
end
