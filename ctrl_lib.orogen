name "ctrl_lib"

import_types_from "base"
using_library "ctrl_lib"


# Repulsive Potential Field method in joint space. One 1-dim. potential field per joint of shape: 
#
#     U = (kp/2) * (1/d - 1/d_0), d <= d_0
#       = 0                     , else
#
#     d = |q-q_0|
#   d_0 = Maximum Influence distance
#   q_0 = Potential field center
#    kp = Proportional gain
#
# Out: acc = vel = -grad(U) = kp * (1/d - 1/d_0) * (q - q_0)/d^2,  d<= d_0
#                           = 0                                 ,  else
#
task_context "JointRepPotField" do
    needs_configuration

    property("q_zero", "base/samples/Joints").
          doc("Potential field center per joint (only position field used)")

    property("d_zero", "base/samples/Joints").
          doc("Maximum influence distance per joint (only position field used)")

    property("pid", "std/vector<base/actuators/PIDValues>").
          doc("PID Gain. I and D values will be ignored. Max PWM will be used as ctrl output saturation.")    
    
    input_port("feedback", "base/samples/Joints").
          doc("Current Joint status")

    output_port("ctrl_out", "base/commands/Joints").
          doc("Output (velocity and effort)")

    # Debug Ports
    output_port("feedback_out", "base/samples/Joints")
    
    periodic 0.1
end


# Repulsive Potential Field method in Cartesian space. 3-dim. radial potential field of shape: 
#
#     U = (kp/2) * (1/d - 1/d_0), d <= d_0
#       = 0                       , else
#
#     d = ||x-x_0||
#   d_0 = Maximum Influence distance
#   x_0 = Potential field center
#    kp = Proportional gain
#
# Out: acc = vel = -grad(U) = kp * (1/d - 1/d_0) * (x - x_0)/d^2,  d<= d_0
#                           = 0                                 ,  else
#
task_context "CartRepPotField" do
    needs_configuration

    property("d_zero", "double").
         doc("Maximum influence distance")

    property("pid", "std/vector<base/actuators/PIDValues>").
         doc("PID Gain. Size 3. I and D values will be ignored. Max PWM will be used as ctrl output saturation.")
 
    property("controlled_frame_frame", "std/string").
         doc("This is the 'end effector' frame of the controlled motion")

    property("controlled_in_frame", "std/string").
         doc("This is the base frame of the controller motion, e.g. the robot base frame")

    property("rep_field_center_frame", "std/string").
         doc("This is the rep_field_center frame of the controller motion")

    output_port("ctrl_out", "base/samples/RigidBodyState").
         doc("Gradient of potential field")
    
    transformer do
      transform 'controlled_in', 'rep_field_center'
      transform 'controlled_in', 'controlled_frame'
      max_latency 0.1
    end

    # Debug Ports
    input_port("rep_field_center", "base/samples/RigidBodyState")
    input_port("controlled_frame", "base/samples/RigidBodyState")
    output_port("controlled_frame_out", "base/samples/RigidBodyState")

    periodic 0.1
end


# Joint PD controller with velocity and acceleration feedfoward term as proposed in 
# Khatib: "Real-time obstacle avoidance for manipulators and mobile robots", 1986
# 
#   v_ctrl_out = kp/kd*(x_r-x), |v_ctrl_out| <= max_vel
#   a_ctrl_out = a_r + kd*(v_ctrl_out + v_r - v), |a_ctrl_out| <= max_acc
#
task_context "JointPDCtrlFeedForward" do
    needs_configuration
   
    property("max_ctrl_out", "base/samples/Joints").
         doc("Max velocities and accelerations can be defined here. If left empty, infinite ctrl output will be allowed")

    property("pid", "std/vector<base/actuators/PIDValues>").
         doc("PID Controller parameters, this property will determine the expected number of inputs and outputs!
              I-Value will be ignored.")

    input_port("setpoint", "base/commands/Joints").
         doc("Reference value for controller. Has to have same size as pid property.
              Position == x_r, speed = v_r, effort = a_r.")

    input_port("feedback", "base/samples/Joints").
         doc("Current joint state. Has to have same size as pid property.
              Position = x, Speed = v. Effort will be ignored.")

    input_port("pid_values", "std/vector<base/actuators/PIDValues>").
         doc("Optional port for online setting new pid values. I-Value will be ignored.")
    
    output_port("ctrl_out", "base/commands/Joints").
         doc("Controller output. Will have same size as pid property. 
              Speed = v_ctrl_out. Effort = a_ctrl_out. Position will not be used.")

    # For debugging
    output_port("feedback_out", "base/samples/Joints")

    periodic 0.1
end


# Cartesian PD controller with acceleration and velocity feedfoward term as proposed in 
# Khatib: "Real-time obstacle avoidance for manipulators and mobile robots", 1986
# 
#   v_ctrl_out = kp/kd*(x_r-x), |v_ctrl_out| <= max_vel
#   a_ctrl_out = a_r + kd*(v_ctrl_out + v_r - v), |a_ctrl_out| <= max_acc
#
task_context "CartPDCtrlFeedForward" do
    needs_configuration

    property("max_ctrl_out", "base/samples/RigidBodyState").
       doc("Max. cartesian velocities and accelerations can be defined here. If left empty, infinite ctrl output will be allowed.")

    property("pid", "std/vector<base/actuators/PIDValues>").
       doc("PID Controller parameters. Size has to be 6!
            I-Value will be ignored. ")
 
    property("controlled_frame_frame", "std/string" ).
       doc("This is the 'end effector' frame of the controlled motion")

    property("controlled_in_frame", "std/string").
       doc("This is the base frame of the controller motion, e.g. the robot base frame")

    property("target_frame", "std/string").
       doc("This is the setpoint frame of the controller motion, e.g. the control target")

    input_port("pid_values", "std/vector<base/actuators/PIDValues>").
       doc("Optional port for online setting new pid values. I-Value will be ignored.")

    output_port("ctrl_out", "base/samples/RigidBodyState").
       doc("Controller output. Velocity/angular_velocity = v_ctrl_out. 
            Acceleration/Angular_acceleration = a_ctrl_out. Position will not be used.")

    transformer do
      transform 'controlled_in', 'setpoint'
      transform 'controlled_in', 'controlled_frame'
      max_latency 0.1
    end

    # Debug Ports: TODO: Do we need these ports anyways? E.g. If we want to 
    # control a velocity that comes from a Force controller?
    # Or create a seperate controller for this purpose?
    input_port("setpoint", "base/samples/RigidBodyState")
    input_port("feedback", "base/samples/RigidBodyState")
    output_port("feedback_out", "base/samples/RigidBodyState")

    periodic 0.1
end

